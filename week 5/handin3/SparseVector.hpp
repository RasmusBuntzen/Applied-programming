#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include<algorithm>
#include<cassert>
#include<vector>
#include<iostream>
//#include"Vector.hpp" We import them like below instead
//#include"Matrix.hpp"

template<class T> class Matrix; 
template<class T> class Vector; 

template<class T> class SparseVector{
private:
	std::vector<T>  indicies;
	std::vector<T> values;
	std::vector<T> actual_vec;

public:
	//creates an empty vector of dimensionality 0.
	SparseVector(){
		indicies = std::vector<T>(0);
		values = std::vector<T>(0);
		actual_vec = std::vector<T>(0);
	}


	// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
	// which need to be set using setValue
	SparseVector(unsigned int dim){
		indicies = std::vector<T>(0);
		values = std::vector<T>(0);
		actual_vec = std::vector<T>(dim);
		std::fill(actual_vec.begin(),actual_vec.end(),0); //makes sure actual_vec is full of 0's
	}

	// assignment operators and copy constructor should be automatically
	// generated by the compiler when using a std::vector for internal storing.
	// However, test that assignment works!

	//sets the value v_i of the vector. if it does not exist it is added
	
	void setValue(unsigned int index, T value){
		auto pointer = std::lower_bound(indicies.begin(),indicies.end(),index); // Here we get a pointer to the first element that is not less than index. This means that  index should be inserted right before the pointer.

		if(pointer != indicies.end() && *pointer != index){ //Here we check that the pointer we found is not the last index (then iterator is the largest in the set) or that the pointer we have found is not equal to the index(I.E the index is already in the set)
		
			int distance = std::distance(indicies.begin(), pointer);//here we get the actual index of the pointer. We can use the index to update values and indicies
			values.insert(values.begin() + distance,value); 
			indicies.insert(indicies.begin() + distance,index);
		}

		else if (pointer != indicies.end() && *pointer == index)
		{ //index already exsists, so we just override the value
			int distance = std::distance(indicies.begin(), pointer);
			//values.insert(values.begin() + distance,value);
			values[distance] = value;
		}
		
		else{ // pointer found is last index
			indicies.push_back(index); // index is added to the end of the index
			values.push_back(value); // add value to end of values
		}
	}

	//returns the value v_i of the vector. Returns 0 if the value is not stored
	T getValue(unsigned int index) const{
		auto pointer = std::find(indicies.begin(),indicies.end(), index); //search for index in indicies
		if(pointer != indicies.end()){ //match is found
			int distance = std::distance(indicies.begin(), pointer);//here we get the actual index of the pointer.
			return values[distance]; //We return the assosiated value with the found index
		}
		else{ //Index ot fount in indicies
			return 0; //the value must therefore be 0
		}
	}

	//returns the dimensionality of the vector
	unsigned int size() const{
		return actual_vec.size(); //return the size of the actual vector
	}

	// returns the number stored elements
	unsigned int nonZeroes() const{
		return indicies.size(); //return size of indicies (number of non 0 elements)
	}

	//returns the index of the ith stored nonzero entry (in increasing order)
	unsigned int indexNonZero(unsigned int i) const{
		//assert(i < nonZeroes()); // i must be less then the number of non zero elements
		return indicies[i]; //Return the ith index of the ith non zero element. I.E the 2.nd non zero element might have index 7 in actual_vec
	}

	//returns the value of the ith stored nonzero entry (in increasing order)
	T valueNonZero(unsigned int i) const{
		//assert(i < nonZeroes());
		return values[i];
	}
	
    void Print(){
        int len = nonZeroes();
        std::cout << "Non zero indicies: [";
        for(int i = 0; i < len; i++){
            std::cout << indicies[i];

            if(i < len-1){ //Print commas between elements
                std::cout << ", ";
            }
        }
        std::cout << "]^T\n" << std::endl;
        std::cout << "Non zero values: [";
        for(int i = 0; i < len; i++){
            std::cout << values[i];

            if(i < len-1){ //Print commas between elements
                std::cout << ", ";
            }
        }
        std::cout << "]^T\n" << std::endl;
    }

	//adds x too the current vector
	SparseVector<T>& operator+= (SparseVector<T> const& x){
		// Iterate over the non-zero elements of vector x
		for (unsigned int i = 0; i < x.nonZeroes(); ++i) {//Loop all non zero values7indicies in x
			unsigned int index = x.indexNonZero(i);//extract index in x and value in x and y
			T value_in_x = x.getValue(index);
			T value_in_y = getValue(index);

			// Add the value to the corresponding element in this vector
			setValue(index, getValue(index) + value_in_x);
    	}
    	return *this;
	}

	//subtracts x from the current vector
	SparseVector<T>& operator-= (SparseVector<T> const& x){
    // Iterate over the non-zero elements of vector x
		for (unsigned int i = 0; i < x.nonZeroes(); ++i) { //Loop all non zero values7indicies in x
			unsigned int index = x.indexNonZero(i); //extract index in x and value in x and y
			T value_in_x = x.getValue(index);
			T value_in_y = getValue(index);

			// Subtract the value from the corresponding element in this vector
			setValue(index, value_in_y - value_in_x); //value from y- value from x
		}
    return *this; // return updated y
	}

};


// computes z= x+y, equivalent to z=x, z+=y
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y){
	SparseVector<T> z = x;
	z +=y;
	return z;
}

// computes z= x-y, equivalent to z=x, z-=y
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y){
	SparseVector<T> z = x;
	z -=y;
	return z;
}

// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T>
Vector<T> operator*(Matrix<T> const& A, SparseVector<T> const& x) {
	//OBS the number of columns in A must be equal to size of x
    int numRows = A.GetNumberOfRows();
    Vector<T> z(numRows); // Resulting dense vector

    for (int i = 0; i < numRows; i++) { // Iterate over each row i of the matrix A
        T sum = 0; // Initialize a sum variable to zero
        for (int j = 0; j < x.size(); j++) { // Iterate over col in A and all elements in x.
            T value = x.getValue(j); 
            sum += A(i, j) * value; // Multiply the element in matrix A at position (i, j) by the corresponding value from x[j].
        }
        z[i] = sum; // add the accumulated sum to z[i]
    }
    return z;
}


// computes the matrix-vector product of a dense matrix and sparse vector z=x^T A (I.E x transposed times A).
// The result is a dense vector.
template<class T>
Vector<T> operator*(SparseVector<T> const& x, Matrix<T> const& A) {

    int numCols = A.GetNumberOfColumns();
    Vector<T> z(numCols); // Resulting dense vector

    for (int j = 0; j < numCols; j++) {//loops through cols in A
        T sum = 0;
        for (int i = 0; i < x.size(); i++) { //Loops through rows in A and all elements in x
            T value = x.getValue(i);
            sum += value * A(i, j);
        }
        z[j] = sum;
    }

    return z;
}
//OBS the two vector matrix multiplications could be sped up by only looping through the non zero values of the SparseVector. Now we loop through some values in the SparseVector that we know are 0 which ofcause does not add anything to the running sum and are just a waste of computing power.
#endif
